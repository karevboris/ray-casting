
uniform sampler3D tex;
uniform vec3 camPos;
uniform vec3 camDir;
uniform vec3 camUp;
uniform vec3 camRight;
uniform float time;

varying vec3 Vertex, Normal;

#define K_A 0.1
#define K_D 1.0
#define K_S 0.3
#define P 32.0
#define LightDir vec3(1,0,0)

const vec3 level_color1 = vec3(0.6);	
const vec3 level_color2 = vec3(0.7,0.55,0.55);	

vec3 Phong ( vec3 point, vec3 normal, vec3 color)
{
	float diffuse = dot ( camDir, normal )*0.5+0.5;
	vec3 reflect = reflect ( -camDir, normal );
	float specular = pow ( max (0.0, dot ( reflect, normalize(camPos-point) ) ), P );
	return K_A * color + diffuse * ( K_D * color + K_S * specular * vec3(1.0) );
}

float Equ(in vec3 arg)
{
	vec3 txt_box1=vec3(-128,-128,0);
	vec3 txt_box2=vec3(128,128,100);
	
	return texture3D(tex, (arg-txt_box1)/(txt_box2-txt_box1)).a;
}

vec3 GradEqu(in vec3 arg, in vec3 cell_size)
{
	vec3 res;
	res.x = Equ(vec3(arg.x+cell_size.x,arg.y,arg.z))-Equ(vec3(arg.x-cell_size.x,arg.y,arg.z));
	res.y = Equ(vec3(arg.x,arg.y+cell_size.y,arg.z))-Equ(vec3(arg.x,arg.y-cell_size.y,arg.z));
	res.z = Equ(vec3(arg.x,arg.y,arg.z+cell_size.z))-Equ(vec3(arg.x,arg.y,arg.z-cell_size.z));
	return normalize(res/cell_size);
}

bool IntersectBox ( vec3 Origin,vec3 Direction, vec3 minimum, vec3 maximum, out float start, out float final )
{
	vec3 OMAX = ( minimum - Origin ) / Direction;
	vec3 OMIN = ( maximum - Origin ) / Direction;
	vec3 MAX = max ( OMAX, OMIN );
	vec3 MIN = min ( OMAX, OMIN );
	final = min ( MAX.x, min ( MAX.y, MAX.z ) );
	start = max ( max ( MIN.x, 0.0), max ( MIN.y, MIN.z ) );	
	return final > start;
} 

struct Ray
{
    vec3 origin;
    vec3 dir;
};

void main(void)
{
	vec3 norm, ray = normalize(Vertex-camPos);
	float step_length=0.25;
	vec3 cell_size=vec3 (1.0, 1.0, 1.0);
		
	vec4 step  = vec4(ray*step_length,step_length);
	vec4 ps = vec4(camPos,0.0);

	float e=0.0,e0=0.0, start,final;
	vec3 box1=vec3(-128,-128,0);
	vec3 box2=vec3(128,128,100);	

	vec2 txt_coord = gl_FragCoord.xy/vec2(256,256);
	vec4 color=vec4(0.0);
	vec4 dist_to_polygon = vec4(0.0, 0.0, 0.0, sqrt(Vertex.y*Vertex.y+sqrt(Vertex.x*Vertex.x+350*350)));
	
	//if(color.w<0.98 && IntersectBox (camPos,ray,box1,box2,start,final ))
	{
		IntersectBox (camPos,ray,box1,box2,start,final );
		final = min(final,dist_to_polygon.w);
		start = max(start,0.0);

		//ps = ps + step*start/step_length;
		ps=vec4(Vertex.x, Vertex.y, 0, 0);
		final=100;
		
		//ps = ps - step*(rand(vec4(gl_FragCoord.xy,pos.xy)))- step;
		
		e = Equ(ps.xyz);
		ps += step;
		float iso_value = 0.05;
		if(e<=iso_value)
		{
		for (float itt = 0.0; ps.w<=final && itt < float ( 2000.0 ); itt+=1.0 )
		{
			e0 = e;
			e = Equ(ps.xyz);
			if(e>iso_value )	break;
			ps += step;
		}
		}/*else
		for (float itt = 0.0; ps.w<=final && itt < float ( 2000.0 ); itt+=1.0 )
		{
			e0 = e;
			e = Equ(ps.xyz);
			if(e<=iso_value )	break;
			ps += step;
		}*/
		
		if(ps.w<=final)
		{
			if(e>iso_value && e0<=iso_value)
			{
				color.xyz = level_color1;
				ps += step * ((iso_value-e)/(e-e0));			//возвращаем луч к изоповерхности для лучшего качества изображения (линейная оценка)
				norm = -GradEqu(ps, cell_size);					//находим нормаль к изоповерхности
			}else
			{
				color.xyz = level_color2;
				ps += step * ((iso_value-e)/(e-e0));			//возвращаем луч к изоповерхности для лучшего качества изображения (линейная оценка)
				norm = GradEqu(ps, cell_size);					//находим нормаль к изоповерхности
			}
			color.xyz = Phong(ps,norm,color.xyz);
			color.w = 1.0;						//поверхность непрозрачна
		}
	}
	
	gl_FragColor = color;
	
}
